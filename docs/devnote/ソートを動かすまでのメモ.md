# ソートを動かすまでのメモ
あまりにわからんくなるので何やったかのメモ。

バブルソートを動かしたいけど、命令専用領域の配列をどう取り扱うか難しい問題があり、それを解決したいというのがあった。
つまりアセンブラで配列が置かれるメモリ領域は素直には読めないので、どう表現すればいいかということに困った。

命令メモリに配置からはlw命令が動かないという問題があった（通常データ領域に働くものなので）
- 命令メモリ：PCでのみアクセス可能
- データメモリ：lw/sw命令でアクセス

そこで、メモリマップを番地ごとに分割することにした。
- 命令メモリ: 0x0000-0x0FFF（配列データもここに）
- データメモリ: 0x1000以上（作業領域）

こんな感じで対応した。
```v
// 統合メモリアクセス: lw命令で命令メモリもアクセス可能にする
wire [31:0] instructionMemData;
wire [9:0] imemWordAddr = ALUResult[11:2]; // 4byte aligned
assign instructionMemData = imem.mem[imemWordAddr];

// アドレス範囲による判定（0x0000-0x0FFF: 命令メモリ, 0x1000以上: データメモリ）
wire accessInstructionMem = (ALUResult < 32'h1000);
wire [31:0] unifiedMemReadData = accessInstructionMem ? instructionMemData : memReadData;
```

## アーキテクチャの話
調べたメモ
### フォン・ノイマン構造
CPU ←→ [統合メモリ]
        (命令とデータ混在)

### ハーバード構造
CPU ←→ [命令メモリ]
    ←→ [データメモリ]

フォンノイマンと比べて、同時アクセスが可能
- 命令フェッチとデータアクセスを同時に実行
- パイプライン処理で性能向上