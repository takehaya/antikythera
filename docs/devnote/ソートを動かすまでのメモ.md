# ソートを動かすまでのメモ
あまりにわからんくなるので何やったかのメモ。

バブルソートを動かしたいけど、命令専用領域の配列をどう取り扱うか難しい問題があり、それを解決したいというのがあった。
つまりアセンブラで配列が置かれるメモリ領域は素直には読めないので、どう表現すればいいかということに困った。

命令メモリに配置からはlw命令が動かないという問題があった（通常データ領域に働くものなので）
- 命令メモリ：PCでのみアクセス可能
- データメモリ：lw/sw命令でアクセス

そこで、メモリマップを番地ごとに分割することにした。
- 命令メモリ: 0x0000-0x0FFF（配列データもここに）
- データメモリ: 0x1000以上（作業領域）

こんな感じで対応した。
```v
// 統合メモリアクセス: lw命令で命令メモリもアクセス可能にする
wire [31:0] instructionMemData;
wire [9:0] imemWordAddr = ALUResult[11:2]; // 4byte aligned
assign instructionMemData = imem.mem[imemWordAddr];

// アドレス範囲による判定（0x0000-0x0FFF: 命令メモリ, 0x1000以上: データメモリ）
wire accessInstructionMem = (ALUResult < 32'h1000);
wire [31:0] unifiedMemReadData = accessInstructionMem ? instructionMemData : memReadData;
```

## アーキテクチャの話
調べたメモ
### フォン・ノイマン構造
CPU ←→ [統合メモリ]
        (命令とデータ混在)

### ハーバード構造
CPU ←→ [命令メモリ]
    ←→ [データメモリ]

フォンノイマンと比べて、同時アクセスが可能
- 命令フェッチとデータアクセスを同時に実行
- パイプライン処理で性能向上

- 命令プログラム: CPU番号で共通化したい
- モジュールごとに引数としてCPUコア番号を与えておく
  - 特別なアドレスを作っておいて、そこにCPU番号を書き込むようにしておく
- メモリをどうするか。
  - atomic命令を実装する必要がある
- local addressを持ってるほうがいい
  - 1000-2000 がそれぞれ自分のメモリとして使う感じ
- メモリはそれぞれCore毎に読む
  - 同時に2つ読めるのは普通ではないので微妙かも
  - 共有メモリを作るなら待つと言うような話が必要
    - 待つって言うのはPCカウンタを止めておいてWriteを0にしてSpinさせるイメージ。
    - PC、レジスタ、メモリを待つようにしたい。
- 0000-1000: 命令とか
- 1000-2000: 一時変数とか
- 2000-3000: 共有メモリ置き場
  - moduleになってて、ストールするかどうかを返すやつがいる
  - 同時に書き込み・読み込みができる。同一アドレスに来てる場合はロックする感じ
  - core1 > core2で、優先度をつける
    - PC write：何もなければ1だけど、ストールする時は0になるカウンタ
    - Reg write: ストールする時は0

- とりあえず共有メモリを一旦作ってテストするを最初に目指す。
- merge sortをやる感じ？
  - バブルソート二つ分でもいいかも。
