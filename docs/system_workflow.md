# デュアルコアCPUシステム ワークフロー図

## システム全体図

```
        MultiCoreCPU (トップレベル)
        ┌─────────────────────────────────────────────────────┐
        │                                                     │
        │  ┌─────────────────┐    ┌─────────────────┐         │
        │  │ SimpleCPUWith   │    │ SimpleCPUWith   │         │
        │  │ MemInterface    │    │ MemInterface    │         │
        │  │    (Core 0)     │    │    (Core 1)     │         │
        │  └─────────┬───────┘    └─────────┬───────┘         │
        │            │                      │                 │
        │            │                      │                 │
        │            └──┬───────────────┬───┘                 │
        │               │               │                     │
        │        ┌──────▼───────────────▼──────┐              │
        │        │  SimpleMemoryArbiter        │              │
        │        │                             │              │
        │        │  ┌─────────┐ ┌─────────────┐│              │
        │        │  │DataMem  │ │InstructionMem││              │
        │        │  │ory      │ │ory          ││              │
        │        │  └─────────┘ └─────────────┘│              │
        │        └─────────────────────────────┘              │
        └─────────────────────────────────────────────────────┘
```

## メモリアクセス調停フロー

### 1. 通常動作（競合なし）

```
時刻T:
Core0: 命令フェッチ (PC=0x1000)
  │
  ├─ imem_req = 1
  ├─ imem_addr = 0x1000
  └─ 調停器 → InstructionMemory → レスポンス

Core1: データアクセス (lw $t0, 0($sp))
  │
  ├─ dmem_req = 1  
  ├─ dmem_addr = 0x2000
  └─ 調停器 → DataMemory → レスポンス

結果: 両コア同時実行、ストールなし
```

### 2. データメモリ競合時

```
時刻T:
Core0: lw $t0, 0($sp)          Core1: sw $t1, 4($sp)
  │                               │
  ├─ dmem_req = 1                ├─ dmem_req = 1
  ├─ dmem_addr = 0x2000          ├─ dmem_addr = 0x2004
  │                               │
  └─ 調停器での判定 ←─────────────────┘
         │
    ┌────▼────┐
    │競合検出  │
    │Core0優先│
    └────┬────┘
         │
    ┌────▼─────────────┐
    │Core0: grant=1    │
    │Core1: stall=1    │
    └──────────────────┘

時刻T+1:
Core0: 正常にデータ読み込み完了
Core1: ストール解除、データ書き込み実行
```

### 3. 命令メモリ競合時

```
時刻T:
Core0: PC=0x1000              Core1: PC=0x1004
  │                             │
  ├─ imem_req = 1              ├─ imem_req = 1
  ├─ imem_addr = 0x1000        ├─ imem_addr = 0x1004
  │                             │
  └─ 調停器での判定 ←──────────────┘
         │
    ┌────▼────┐
    │競合検出  │
    │Core0優先│
    └────┬────┘
         │
    ┌────▼─────────────────────────┐
    │Core0: grant=1, 命令取得      │
    │Core1: stall=1, PC保持       │
    └──────────────────────────────┘

時刻T+1:  
Core0: 取得した命令を実行
Core1: PC=0x1004で命令フェッチ実行
```

## CPUストール動作詳細

### ストール時のCPU状態変化

```
通常動作時:
┌─────┬─────┬─────┬─────┬─────┐
│ IF  │ ID  │ EX  │ MEM │ WB  │  ← パイプライン段階
├─────┼─────┼─────┼─────┼─────┤
│PC++ │Inst │ALU  │Mem  │Reg  │  ← 各段階の動作
└─────┴─────┴─────┴─────┴─────┘

ストール時:
┌─────┬─────┬─────┬─────┬─────┐
│ IF  │ ID  │ EX  │ MEM │ WB  │  
├─────┼─────┼─────┼─────┼─────┤
│PC保持│Inst │ALU  │待機 │停止 │  ← ストール状態
└─────┴─────┴─────┴─────┴─────┘
```

### ストール制御信号の流れ

```
SimpleMemoryArbiter
  │
  ├─ 競合検出
  │   ├─ core0_dmem_req && core1_dmem_req
  │   └─ core0_imem_req && core1_imem_req
  │
  ├─ 優先度判定 (Core0優先)
  │   ├─ core0_grant = core0_req
  │   └─ core1_grant = core1_req && !core0_req
  │
  └─ ストール信号生成
      ├─ core0_stall = 0 (常に優先)
      └─ core1_stall = core1_req && !core1_grant

SimpleCPUWithMemInterface (Core1)
  │
  ├─ stall信号受信
  │
  ├─ PC更新制御
  │   └─ if (!stall) PC <= PCnext;
  │
  └─ レジスタ書き込み制御  
      └─ RegWrite && !stall
```

## システム初期化シーケンス

```
1. リセット信号アサート
   ├─ MultiCoreCPU.reset = 1
   ├─ 各CPU: PC = 0
   ├─ 各CPU: レジスタクリア
   └─ SimpleMemoryArbiter: 初期化

2. リセット解除
   ├─ MultiCoreCPU.reset = 0
   ├─ Core0: PC=0から実行開始
   ├─ Core1: PC=0から実行開始  
   └─ 調停器: 通常動作開始

3. 定常動作
   ├─ 各コア独立実行
   ├─ メモリ競合時ストール
   └─ デバッグレジスタ出力
```

## パフォーマンス特性

### 理想的なケース（競合なし）
```
時刻: T1    T2    T3    T4    T5
Core0: [I1]  [I2]  [I3]  [I4]  [I5]
Core1: [I1]  [I2]  [I3]  [I4]  [I5]
総実行: 2命令/サイクル
```

### 命令競合が多いケース
```
時刻: T1    T2    T3    T4    T5
Core0: [I1]  [I2]  [I3]  [I4]  [I5]  
Core1: [--]  [I1]  [--]  [I2]  [--]
総実行: 1.5命令/サイクル
```

### データ競合が多いケース  
```
時刻: T1    T2    T3    T4    T5
Core0: [I1]  [I2]  [I3]  [I4]  [I5]
Core1: [I1]  [I2]  [--]  [I3]  [I4]
総実行: 1.8命令/サイクル
```
